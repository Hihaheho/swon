#[allow(dead_code)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum NonTerminalKind {
    Array,
    ArrayBegin,
    ArrayEnd,
    ArrayList,
    ArrayMarker,
    ArrayMarkerOpt,
    ArrayOpt,
    At,
    Begin,
    Bind,
    Binding,
    BindingRhs,
    Boolean,
    Code,
    CodeBlock,
    Comma,
    Continue,
    Dot,
    End,
    Ext,
    ExtensionNameSpace,
    False,
    Hole,
    Ident,
    InStr,
    Integer,
    Key,
    KeyBase,
    KeyOpt,
    Keys,
    KeysList,
    NamedCode,
    Newline,
    Null,
    Object,
    ObjectList,
    ObjectOpt,
    Quote,
    Section,
    SectionBinding,
    SectionBody,
    SectionBodyList,
    Str,
    StrContinues,
    StrContinuesList,
    Swon,
    SwonList,
    SwonList0,
    Text,
    TextBinding,
    TextBindingOpt,
    TextStart,
    True,
    TypedQuote,
    TypedStr,
    Value,
    ValueBinding,
    Ws,
    Root,
}
#[allow(dead_code)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum TerminalKind {
    NewLine,
    Whitespace,
    LineComment,
    BlockComment,
    Integer,
    True,
    False,
    Null,
    Hole,
    Quote,
    TypedQuote,
    InStr,
    Text,
    CodeBlock,
    NamedCode,
    Code,
    Newline,
    Ws,
    At,
    Dollar,
    Dot,
    LBrace,
    RBrace,
    LBracket,
    RBracket,
    Bind,
    Comma,
    Esc,
    TextStart,
    Ident,
}
#[allow(dead_code)]
impl TerminalKind {
    pub fn from_terminal_index(index: u16) -> Self {
        match index {
            1 => Self::NewLine,
            2 => Self::Whitespace,
            3 => Self::LineComment,
            4 => Self::BlockComment,
            5 => Self::Integer,
            6 => Self::True,
            7 => Self::False,
            8 => Self::Null,
            9 => Self::Hole,
            10 => Self::Quote,
            11 => Self::TypedQuote,
            12 => Self::InStr,
            13 => Self::Text,
            14 => Self::CodeBlock,
            15 => Self::NamedCode,
            16 => Self::Code,
            17 => Self::Newline,
            18 => Self::Ws,
            19 => Self::At,
            20 => Self::Dollar,
            21 => Self::Dot,
            22 => Self::LBrace,
            23 => Self::RBrace,
            24 => Self::LBracket,
            25 => Self::RBracket,
            26 => Self::Bind,
            27 => Self::Comma,
            28 => Self::Esc,
            29 => Self::TextStart,
            30 => Self::Ident,
            _ => panic!("Invalid terminal index: {}", index),
        }
    }
    pub fn is_builtin_terminal(&self) -> bool {
        matches!(
            self,
            TerminalKind::NewLine
                | TerminalKind::Whitespace
                | TerminalKind::LineComment
                | TerminalKind::BlockComment
        )
    }
    pub fn is_builtin_new_line(&self) -> bool {
        matches!(self, TerminalKind::NewLine)
    }
    pub fn is_builtin_whitespace(&self) -> bool {
        matches!(self, TerminalKind::Whitespace)
    }
    pub fn is_builtin_line_comment(&self) -> bool {
        matches!(self, TerminalKind::LineComment)
    }
    pub fn is_builtin_block_comment(&self) -> bool {
        matches!(self, TerminalKind::BlockComment)
    }
}

#[allow(dead_code)]
impl NonTerminalKind {
    pub fn from_non_terminal_name(name: &str) -> Self {
        match name {
            "Array" => Self::Array,
            "ArrayBegin" => Self::ArrayBegin,
            "ArrayEnd" => Self::ArrayEnd,
            "ArrayList" => Self::ArrayList,
            "ArrayMarker" => Self::ArrayMarker,
            "ArrayMarkerOpt" => Self::ArrayMarkerOpt,
            "ArrayOpt" => Self::ArrayOpt,
            "At" => Self::At,
            "Begin" => Self::Begin,
            "Bind" => Self::Bind,
            "Binding" => Self::Binding,
            "BindingRhs" => Self::BindingRhs,
            "Boolean" => Self::Boolean,
            "Code" => Self::Code,
            "CodeBlock" => Self::CodeBlock,
            "Comma" => Self::Comma,
            "Continue" => Self::Continue,
            "Dot" => Self::Dot,
            "End" => Self::End,
            "Ext" => Self::Ext,
            "ExtensionNameSpace" => Self::ExtensionNameSpace,
            "False" => Self::False,
            "Hole" => Self::Hole,
            "Ident" => Self::Ident,
            "InStr" => Self::InStr,
            "Integer" => Self::Integer,
            "Key" => Self::Key,
            "KeyBase" => Self::KeyBase,
            "KeyOpt" => Self::KeyOpt,
            "Keys" => Self::Keys,
            "KeysList" => Self::KeysList,
            "NamedCode" => Self::NamedCode,
            "Newline" => Self::Newline,
            "Null" => Self::Null,
            "Object" => Self::Object,
            "ObjectList" => Self::ObjectList,
            "ObjectOpt" => Self::ObjectOpt,
            "Quote" => Self::Quote,
            "Section" => Self::Section,
            "SectionBinding" => Self::SectionBinding,
            "SectionBody" => Self::SectionBody,
            "SectionBodyList" => Self::SectionBodyList,
            "Str" => Self::Str,
            "StrContinues" => Self::StrContinues,
            "StrContinuesList" => Self::StrContinuesList,
            "Swon" => Self::Swon,
            "SwonList" => Self::SwonList,
            "SwonList0" => Self::SwonList0,
            "Text" => Self::Text,
            "TextBinding" => Self::TextBinding,
            "TextBindingOpt" => Self::TextBindingOpt,
            "TextStart" => Self::TextStart,
            "True" => Self::True,
            "TypedQuote" => Self::TypedQuote,
            "TypedStr" => Self::TypedStr,
            "Value" => Self::Value,
            "ValueBinding" => Self::ValueBinding,
            "Ws" => Self::Ws,
            "" => Self::Root,
            _ => panic!("Invalid non-terminal name: {}", name),
        }
    }
}
impl std::fmt::Display for TerminalKind {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::NewLine => write!(f, stringify!(NewLine)),
            Self::Whitespace => write!(f, stringify!(Whitespace)),
            Self::LineComment => write!(f, stringify!(LineComment)),
            Self::BlockComment => write!(f, stringify!(BlockComment)),
            Self::Integer => write!(f, stringify!(Integer)),
            Self::True => write!(f, stringify!(True)),
            Self::False => write!(f, stringify!(False)),
            Self::Null => write!(f, stringify!(Null)),
            Self::Hole => write!(f, stringify!(Hole)),
            Self::Quote => write!(f, stringify!(Quote)),
            Self::TypedQuote => write!(f, stringify!(TypedQuote)),
            Self::InStr => write!(f, stringify!(InStr)),
            Self::Text => write!(f, stringify!(Text)),
            Self::CodeBlock => write!(f, stringify!(CodeBlock)),
            Self::NamedCode => write!(f, stringify!(NamedCode)),
            Self::Code => write!(f, stringify!(Code)),
            Self::Newline => write!(f, stringify!(Newline)),
            Self::Ws => write!(f, stringify!(Ws)),
            Self::At => write!(f, stringify!(At)),
            Self::Dollar => write!(f, stringify!(Dollar)),
            Self::Dot => write!(f, stringify!(Dot)),
            Self::LBrace => write!(f, stringify!(LBrace)),
            Self::RBrace => write!(f, stringify!(RBrace)),
            Self::LBracket => write!(f, stringify!(LBracket)),
            Self::RBracket => write!(f, stringify!(RBracket)),
            Self::Bind => write!(f, stringify!(Bind)),
            Self::Comma => write!(f, stringify!(Comma)),
            Self::Esc => write!(f, stringify!(Esc)),
            Self::TextStart => write!(f, stringify!(TextStart)),
            Self::Ident => write!(f, stringify!(Ident)),
        }
    }
}

impl std::fmt::Display for NonTerminalKind {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Array => write!(f, stringify!(Array)),
            Self::ArrayBegin => write!(f, stringify!(ArrayBegin)),
            Self::ArrayEnd => write!(f, stringify!(ArrayEnd)),
            Self::ArrayList => write!(f, stringify!(ArrayList)),
            Self::ArrayMarker => write!(f, stringify!(ArrayMarker)),
            Self::ArrayMarkerOpt => write!(f, stringify!(ArrayMarkerOpt)),
            Self::ArrayOpt => write!(f, stringify!(ArrayOpt)),
            Self::At => write!(f, stringify!(At)),
            Self::Begin => write!(f, stringify!(Begin)),
            Self::Bind => write!(f, stringify!(Bind)),
            Self::Binding => write!(f, stringify!(Binding)),
            Self::BindingRhs => write!(f, stringify!(BindingRhs)),
            Self::Boolean => write!(f, stringify!(Boolean)),
            Self::Code => write!(f, stringify!(Code)),
            Self::CodeBlock => write!(f, stringify!(CodeBlock)),
            Self::Comma => write!(f, stringify!(Comma)),
            Self::Continue => write!(f, stringify!(Continue)),
            Self::Dot => write!(f, stringify!(Dot)),
            Self::End => write!(f, stringify!(End)),
            Self::Ext => write!(f, stringify!(Ext)),
            Self::ExtensionNameSpace => write!(f, stringify!(ExtensionNameSpace)),
            Self::False => write!(f, stringify!(False)),
            Self::Hole => write!(f, stringify!(Hole)),
            Self::Ident => write!(f, stringify!(Ident)),
            Self::InStr => write!(f, stringify!(InStr)),
            Self::Integer => write!(f, stringify!(Integer)),
            Self::Key => write!(f, stringify!(Key)),
            Self::KeyBase => write!(f, stringify!(KeyBase)),
            Self::KeyOpt => write!(f, stringify!(KeyOpt)),
            Self::Keys => write!(f, stringify!(Keys)),
            Self::KeysList => write!(f, stringify!(KeysList)),
            Self::NamedCode => write!(f, stringify!(NamedCode)),
            Self::Newline => write!(f, stringify!(Newline)),
            Self::Null => write!(f, stringify!(Null)),
            Self::Object => write!(f, stringify!(Object)),
            Self::ObjectList => write!(f, stringify!(ObjectList)),
            Self::ObjectOpt => write!(f, stringify!(ObjectOpt)),
            Self::Quote => write!(f, stringify!(Quote)),
            Self::Section => write!(f, stringify!(Section)),
            Self::SectionBinding => write!(f, stringify!(SectionBinding)),
            Self::SectionBody => write!(f, stringify!(SectionBody)),
            Self::SectionBodyList => write!(f, stringify!(SectionBodyList)),
            Self::Str => write!(f, stringify!(Str)),
            Self::StrContinues => write!(f, stringify!(StrContinues)),
            Self::StrContinuesList => write!(f, stringify!(StrContinuesList)),
            Self::Swon => write!(f, stringify!(Swon)),
            Self::SwonList => write!(f, stringify!(SwonList)),
            Self::SwonList0 => write!(f, stringify!(SwonList0)),
            Self::Text => write!(f, stringify!(Text)),
            Self::TextBinding => write!(f, stringify!(TextBinding)),
            Self::TextBindingOpt => write!(f, stringify!(TextBindingOpt)),
            Self::TextStart => write!(f, stringify!(TextStart)),
            Self::True => write!(f, stringify!(True)),
            Self::TypedQuote => write!(f, stringify!(TypedQuote)),
            Self::TypedStr => write!(f, stringify!(TypedStr)),
            Self::Value => write!(f, stringify!(Value)),
            Self::ValueBinding => write!(f, stringify!(ValueBinding)),
            Self::Ws => write!(f, stringify!(Ws)),
            Self::Root => write!(f, stringify!(Root)),
        }
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub enum NodeKind<T, Nt> {
    Terminal(T),
    NonTerminal(Nt),
}
